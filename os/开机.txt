重点：为什么bootsect加载sys模块只是移到0x1000处呢？
	理论上操作系统应该位于0地址开始处，方便操作系统运行，但是在setup中还需要用到bios的中断描述符，比如调用0x10进行打印等等。而中断描述符被bootsect加载至0地址处，所以要等setup快执行完时才可以把sys模块（os）移到0地址处
 setup在最后一步把1赋值给了cr0寄存器（cpu通过该寄存器来确定用哪种寻址方式），保护模式下cs左移四位加上ip为目标点（cs中存放的就是地址），转为保护模式后cs存的位置是段选择子（查GDT表的索引，GDT表在setup中被初始化）。注意gdt表一个表项占64位，8字节，通过硬件规定这8字节所代表的地址为32位地址（gdt表其他位用来表示其他信息）

进入保护模式后cs中的值就是取gdt表中的索引


setup的作用：首先通过中断读硬件参数，写到0x90000地址处（覆盖掉bootsect），初始化一部分idt（中断描述符表），一部分gdt表，然后把sys操纵系统模块挪到0地址处，然后通过cr0启动保护模式，最后jmpi 0，8（查询gdt表的第8到16字节，因为一个表项8字节，通过硬件翻译过来是跳到0x0000处执行，即操作系统起始处。至此，操作系统开始启动。启动后执行head.s文件，初始化完整的idt和gdt 前面只是初始一部分用来跳转，head.s加载main函数，main函数初始化内存，显卡等等等等，初始化需要的硬件参数都从0x90000取